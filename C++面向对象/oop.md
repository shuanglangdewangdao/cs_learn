# 类的设计

基础原则是，本身代码不要修改

1. 首先抽出要实现的概念

2. 用一系列的纯虚函数实现这些接口

3. 在用特例完成实现


## 对象抽出

判断问题可以通过将判断问题对象化，使用状态函数实现类。

## 接口

作为辅助函数，方便修改类的实现

### 使用方法

将该函数设为纯虚函数，具体实现有子类完成

## eg：模板方法

1. 抽象出抽象概念，设计接口类
2. 继承并实现
3. 避免大规模修改


# 例子

## 负载监视器

通用负载监视器

1. 用switch找到相应系统（垃圾）
2. 模板方法（冗余问题）

### 解决方法

1. 静态可变(同一功能的不同实现)（相对于基类的改变）用继承，动态可变（各自独立的功能）用组合

单一责任原则：派生一个类只有一个理由

策略类（可以再运行期改变）

本质上是类指针


分清变与不变

分清可变的组织层面


2. 抽象部分与实现部分的分离

注意：析构函数定义为纯虚函数


## 类模板

1. 迭代器

分离存储与访问（可变的存储，不变的访问）

注：使用不等于号而不是小于等于

迭代器的接口：

初始化：赋值

不等：！=

++

->或*


2. 数组的迭代器


迭代器模式：隐藏内部表示，提供访问方法


模板：

泛化数据类型的算法


容器：存储数据，数据的表示

算法：处理数据，抽象的算法表示


数据类型：值，可进行的操作

算法只与可用操作有关，只要用当前数据类型上重载这种可用操作，就可以实现通用算法


### 不变

算法/抽象结构与实现均不变

数据的访问接口不变

数据可用操作不变

### 变

组织形式

数据类型


### 把函数变为对象

对（）重载，函数对象

### 基于模板的策略模式

基于模板的组合

## 基于已有资源的开发

1. 模板实例化
2. 组合
3. 逻辑关系使用继承

### 栈

1. 基于数组实现栈
2. 使用vector实现栈

### 适当引入接口

#### 适配器模式

功能上满足需求，但接口不对

实现方法

1. 组合
2. 多重继承（不推荐使用）


### 引用计数

引用计数不为0不释放对象

### 延迟初始化（代理模式）

延迟到使用时初始化

使用代理，到使用时才初始化

### eg

接口不变，增加功能

#### 使用装饰模式

对主体进行不同的装饰

策略：修改内核，需要了解要什么策略

装饰：修改外壳，无需了解装饰内容

装饰可以看作一系列代理，但更注重功能的添加

### 责任链

_sucesor:后继处理者

多个请求处理连接起来

强调行为，任何一级都可能停止

主要是为了控制多个对象的行为