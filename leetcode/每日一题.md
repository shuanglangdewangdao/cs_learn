# 5.19

You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k.

The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed).

Find the kth largest value (1-indexed) of all the coordinates of matrix.

 
***
Example 1:

Input: matrix = [[5,2],[1,6]], k = 1

Output: 7

Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.
***
Example 2:

Input: matrix = [[5,2],[1,6]], k = 2

Output: 5

Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.
***
Example 3:

Input: matrix = [[5,2],[1,6]], k = 3

Output: 4

Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.
***
Example 4:

Input: matrix = [[5,2],[1,6]], k = 4

Output: 0

Explanation: The value of coordinate (1,1) is 5 XOR 2 XOR 1 XOR 6 = 0, which is the 4th largest value.

## 提示

暴力就可以了

## 程序

***

    func quickSelect(a []int, k int) int {
        rand.Shuffle(len(a), func(i, j int) { a[i], a[j] = a[j], a[i] })
        for l, r := 0, len(a)-1; l < r; {
            v := a[l]
            i, j := l, r+1
            for {
                for i++; i < r && a[i] < v; i++ {
                }
                for j--; j > l && a[j] > v; j-- {
                }
                if i >= j {
                    break
                }
                a[i], a[j] = a[j], a[i]
            }
            a[l], a[j] = a[j], v
            if j == k {
                break
            } else if j < k {
                l = j + 1
            } else {
                r = j - 1
            }
        }
        return a[k]
    }
    
    func kthLargestValue(matrix [][]int, k int) int {
    m,n:=len(matrix),len(matrix[0])
    opt:=make([]int,m*n)
    dp:=make([][]int,m+1)
    dp[0]=make([]int,n+1)
    for i,row := range matrix{
        dp[i+1]=make([]int,n+1)
        for j,value:=range row{
            dp[i+1][j+1]=dp[i][j+1]^dp[i+1][j]^dp[i][j]^value
            opt[j+i*n]=dp[i+1][j+1]
        }
    } 
    
    return quickSelect(opt,m*n-k)
    }


# 5.21

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：

 nums1[i] == nums2[j]

且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

## ex
 
***
示例 1：

输入：nums1 = [1,4,2], nums2 = [1,2,4]

输出：2

解释：可以画出两条不交叉的线，如上图所示。
 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。

***

示例 2：

输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]

输出：3

***
示例 3：

输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出：2
***

## 提示

相对位置相同的子串，可以使用最长公共子串

## 程序

    func maxUncrossedLines(nums1 []int, nums2 []int) int {
    
    m:=len(nums1)
    n:=len(nums2)
    
    dp:=make([][]int,m+1)
    
    dp[0]=make([]int,n+1)
    
    for i,v:=range nums1{
        dp[i+1]=make([]int,n+1)
        for j,w:=range nums2{
            if v==w{
                dp[i+1][j+1]=dp[i][j]+1
            }else{
                dp[i+1][j+1] =max(dp[i+1][j],dp[i][j+1])
            }
        }
    }
    return dp[m][n]
    }
    
    func max(a int,b int)int{
        if a > b{
            return a
        }
        return b
    }


# 5.24

有台奇怪的打印机有以下两个特殊要求：

打印机每次只能打印由 同一个字符 组成的序列。
每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。
给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。

***
 
示例 1：

输入：s = "aaabbb"

输出：2

解释：首先打印 "aaa" 然后打印 "bbb"。

***

示例 2：

输入：s = "aba"

输出：2

解释：首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。


## 提示

使用动态规划，记录区间最小值
重点在于确定具体方程

$$

f[i][j]=\left\{\begin{array}{ll}
f[i][j-1] & s[i]=s[j] \\
min(f[i][k]+f[k+1][j]) & s[i] \neq s[j]
\end{array}\right.

$$


    func strangePrinter(s string) int {
        n := len(s)
        f := make([][]int, n)
        for i := range f {
            f[i] = make([]int, n)
        }
        for i := n - 1; i >= 0; i-- {
            f[i][i] = 1
            for j := i + 1; j < n; j++ {
                if s[i] == s[j] {
                    f[i][j] = f[i][j-1]
                } else {
                    f[i][j] = math.MaxInt64
                    for k := i; k < j; k++ {
                        f[i][j] = min(f[i][j], f[i][k]+f[k+1][j])
                    }
                }
            }
        }
        return f[0][n-1]
    }
    
    func min(a, b int) int {
        if a < b {
            return a
        }
        return b
    }

# 5.26

反转每对括号间的子串
给出一个字符串 s（仅含有小写英文字母和括号）。
请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。
注意，您的结果中 不应 包含任何括号。

***
示例 1：

输入：s = "(abcd)"

输出："dcba"

***

示例 2：

输入：s = "(u(love)i)"

输出："iloveu"

***

示例 3：

输入：s = "(ed(et(oc))el)"

输出："leetcode"

***

示例 4：

输入：s = "a(bcdefghijkl(mno)p)q"

输出："apmnolkjihgfedcbq"

## 提示

根据括号次数判断文段是否翻转，本质是一种分治算法


## 代码

    func reverseParentheses(s string) string {
        n := len(s)
        pair := make([]int, n)
        stack := []int{}
        for i, b := range s {
            if b == '(' {
                stack = append(stack, i)
            } else if b == ')' {
                j := stack[len(stack)-1]
                stack = stack[:len(stack)-1]
                pair[i], pair[j] = j, i
            }
        }
        ans := []byte{}
        for i, step := 0, 1; i < n; i += step {
            if s[i] == '(' || s[i] == ')' {
                i = pair[i]
                step = -step
            } else {
                ans = append(ans, s[i])
            }
        }
        return string(ans)
    }

# 5.29

两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。计算一个数组中，任意两个数之间汉明距离的总和。
***
示例:

输入: 4, 14, 2

输出: 6

解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）
所以答案为：
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.

***

## 提示

面对正向思考下会需要多重嵌套循环的问题，逆向思考可能会简单点

    unc totalHammingDistance(nums []int) (ans int) {
       n := len(nums)
       for i := 0; i < 30; i++ {
           c := 0
           for _, val := range nums {
               c += val >> i &1
           } 
           ans += c * (n - c)
       }
       return
    }