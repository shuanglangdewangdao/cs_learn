# 5.19

You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k.

The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 <= i <= a < m and 0 <= j <= b < n (0-indexed).

Find the kth largest value (1-indexed) of all the coordinates of matrix.

 
***
Example 1:

Input: matrix = [[5,2],[1,6]], k = 1

Output: 7

Explanation: The value of coordinate (0,1) is 5 XOR 2 = 7, which is the largest value.
***
Example 2:

Input: matrix = [[5,2],[1,6]], k = 2

Output: 5

Explanation: The value of coordinate (0,0) is 5 = 5, which is the 2nd largest value.
***
Example 3:

Input: matrix = [[5,2],[1,6]], k = 3

Output: 4

Explanation: The value of coordinate (1,0) is 5 XOR 1 = 4, which is the 3rd largest value.
***
Example 4:

Input: matrix = [[5,2],[1,6]], k = 4

Output: 0

Explanation: The value of coordinate (1,1) is 5 XOR 2 XOR 1 XOR 6 = 0, which is the 4th largest value.

## 提示

暴力就可以了

## 程序

***

    func quickSelect(a []int, k int) int {
        rand.Shuffle(len(a), func(i, j int) { a[i], a[j] = a[j], a[i] })
        for l, r := 0, len(a)-1; l < r; {
            v := a[l]
            i, j := l, r+1
            for {
                for i++; i < r && a[i] < v; i++ {
                }
                for j--; j > l && a[j] > v; j-- {
                }
                if i >= j {
                    break
                }
                a[i], a[j] = a[j], a[i]
            }
            a[l], a[j] = a[j], v
            if j == k {
                break
            } else if j < k {
                l = j + 1
            } else {
                r = j - 1
            }
        }
        return a[k]
    }
    
    func kthLargestValue(matrix [][]int, k int) int {
    m,n:=len(matrix),len(matrix[0])
    opt:=make([]int,m*n)
    dp:=make([][]int,m+1)
    dp[0]=make([]int,n+1)
    for i,row := range matrix{
        dp[i+1]=make([]int,n+1)
        for j,value:=range row{
            dp[i+1][j+1]=dp[i][j+1]^dp[i+1][j]^dp[i][j]^value
            opt[j+i*n]=dp[i+1][j+1]
        }
    } 
    
    return quickSelect(opt,m*n-k)
    }


# 5.21

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：

 nums1[i] == nums2[j]

且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

## ex
 
***
示例 1：

输入：nums1 = [1,4,2], nums2 = [1,2,4]

输出：2

解释：可以画出两条不交叉的线，如上图所示。
 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。

***

示例 2：

输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]

输出：3

***
示例 3：

输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出：2
***

## 提示

相对位置相同的子串，可以使用最长公共子串

## 程序

    func maxUncrossedLines(nums1 []int, nums2 []int) int {
    
    m:=len(nums1)
    n:=len(nums2)
    
    dp:=make([][]int,m+1)
    
    dp[0]=make([]int,n+1)
    
    for i,v:=range nums1{
        dp[i+1]=make([]int,n+1)
        for j,w:=range nums2{
            if v==w{
                dp[i+1][j+1]=dp[i][j]+1
            }else{
                dp[i+1][j+1] =max(dp[i+1][j],dp[i][j+1])
            }
        }
    }
    return dp[m][n]
    }
    
    func max(a int,b int)int{
        if a > b{
            return a
        }
        return b
    }


# 5.24

有台奇怪的打印机有以下两个特殊要求：

打印机每次只能打印由 同一个字符 组成的序列。
每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。
给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。

***
 
示例 1：

输入：s = "aaabbb"

输出：2

解释：首先打印 "aaa" 然后打印 "bbb"。

***

示例 2：

输入：s = "aba"

输出：2

解释：首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。


## 提示

使用动态规划，记录区间最小值
重点在于确定具体方程

$$

f[i][j]=\left\{\begin{array}{ll}
f[i][j-1] & s[i]=s[j] \\
min(f[i][k]+f[k+1][j]) & s[i] \neq s[j]
\end{array}\right.

$$


    func strangePrinter(s string) int {
        n := len(s)
        f := make([][]int, n)
        for i := range f {
            f[i] = make([]int, n)
        }
        for i := n - 1; i >= 0; i-- {
            f[i][i] = 1
            for j := i + 1; j < n; j++ {
                if s[i] == s[j] {
                    f[i][j] = f[i][j-1]
                } else {
                    f[i][j] = math.MaxInt64
                    for k := i; k < j; k++ {
                        f[i][j] = min(f[i][j], f[i][k]+f[k+1][j])
                    }
                }
            }
        }
        return f[0][n-1]
    }
    
    func min(a, b int) int {
        if a < b {
            return a
        }
        return b
    }

# 5.26

反转每对括号间的子串
给出一个字符串 s（仅含有小写英文字母和括号）。
请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。
注意，您的结果中 不应 包含任何括号。

***
示例 1：

输入：s = "(abcd)"

输出："dcba"

***

示例 2：

输入：s = "(u(love)i)"

输出："iloveu"

***

示例 3：

输入：s = "(ed(et(oc))el)"

输出："leetcode"

***

示例 4：

输入：s = "a(bcdefghijkl(mno)p)q"

输出："apmnolkjihgfedcbq"

## 提示

根据括号次数判断文段是否翻转，本质是一种分治算法


## 代码

    func reverseParentheses(s string) string {
        n := len(s)
        pair := make([]int, n)
        stack := []int{}
        for i, b := range s {
            if b == '(' {
                stack = append(stack, i)
            } else if b == ')' {
                j := stack[len(stack)-1]
                stack = stack[:len(stack)-1]
                pair[i], pair[j] = j, i
            }
        }
        ans := []byte{}
        for i, step := 0, 1; i < n; i += step {
            if s[i] == '(' || s[i] == ')' {
                i = pair[i]
                step = -step
            } else {
                ans = append(ans, s[i])
            }
        }
        return string(ans)
    }

# 5.29

1074. 元素和为目标值的子矩阵数量


给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。
子矩阵 x1, y1, x2, y2 是满足 x1 <= x <= x2 且 y1 <= y <= y2 的所有单元 matrix[x][y] 的集合。
如果 (x1, y1, x2, y2) 和 (x1', y1', x2', y2') 两个子矩阵中部分坐标不同（如：x1 != x1'），那么这两个子矩阵也不同。

## 提示

通过一系列操作实现二维转为一维问题

## 代码

    func subarraySum(nums []int, k int) (ans int) {
        mp := map[int]int{0: 1}
        for i, pre := 0, 0; i < len(nums); i++ {
            pre += nums[i]
            if _, ok := mp[pre-k]; ok {
                ans += mp[pre-k]
            }
            mp[pre]++
        }
        return
    }
    
    func numSubmatrixSumTarget(matrix [][]int, target int) (ans int) {
        for i := range matrix { // 枚举上边界
            sum := make([]int, len(matrix[0]))
            for _, row := range matrix[i:] { // 枚举下边界
                for c, v := range row {
                    sum[c] += v // 更新每列的元素和
                }
                ans += subarraySum(sum, target)
            }
        }
        return
    }
    
    //二维问题，一维化

# 5.30

两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。计算一个数组中，任意两个数之间汉明距离的总和。
***
示例:

输入: 4, 14, 2

输出: 6

解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）
所以答案为：
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.

***

## 提示

面对正向思考下会需要多重嵌套循环的问题，逆向思考可能会简单点

    unc totalHammingDistance(nums []int) (ans int) {
       n := len(nums)
       for i := 0; i < 30; i++ {
           c := 0
           for _, val := range nums {
               c += val >> i &1
           } 
           ans += c * (n - c)
       }
       return
    }
***

# 5.31

1.   4的幂


给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x

## 提示

多使用位运算

## 代码

    func isPowerOfFour(n int) bool {
        return n > 0 && n&(n-1) == 0 && n&0x2aaaaaaa == 0
    }
    func isPowerOfFour(n int) bool {
        return n > 0 && n&(n-1) == 0 && n%3 == 1
    }

# 6.1

1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？

给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。

你按照如下规则进行一场游戏：

你从第 0 天开始吃糖果。
你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。
在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。

请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。

请你返回得到的数组 answer 。

## 代码

    // func canEat(candiesCount []int, queries [][]int) []bool{
    //     m:=len(candiesCount)
    //     n:=len(queries)
    //     eatcandy:=make([]int,m)
    //     ans:=make([]bool,n)
    //     mineat:=0
    //     maxeat:=0
    //     sum:=0
    //     for i:=0;i<m;i++{
    //         sum+=candiesCount[i]
    //         eatcandy[i]=sum
    //     }
    //     for i:=0;i<n;i++{
    //         mineat=queries[i][1]+1
    //         maxeat=(queries[i][1]+1)*queries[i][2]
    //         if queries[i][0]==0{
    //             if mineat <= eatcandy[queries[i][0]] && maxeat > 0{
    //                 ans[i]=true
    //             }
    //         }else{
    //             if mineat <= eatcandy[queries[i][0]] && maxeat > eatcandy[queries[i][0]-1]{
    //                 ans[i]=true
    //             }          
    //         }
    //     }
    //     return ans
    // }

    func canEat(candiesCount []int, queries [][]int) []bool {
        n := len(candiesCount)

        // 前缀和
        sum := make([]int, n)
        sum[0] = candiesCount[0]
        for i := 1; i < n; i++ {
            sum[i] = sum[i-1] + candiesCount[i]
        }

        ans := make([]bool, len(queries))
        for i, q := range queries {
            favoriteType, favoriteDay, dailyCap := q[0], q[1], q[2]

            x1 := favoriteDay + 1
            y1 := (favoriteDay + 1) * dailyCap
            x2 := 1
            if favoriteType > 0 {
                x2 = sum[favoriteType-1] + 1
            }
            y2 := sum[favoriteType]

            ans[i] = !(x1 > y2 || y1 < x2)
        }
        return ans
    }
# 6.2

523. 连续的子数组和
给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：

子数组大小 至少为 2 ，且子数组元素总和为 k 的倍数。如果存在，返回 true ；否则，返回 false 。

如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。

## 提示

前缀和+哈希

## 代码

    func checkSubarraySum(nums []int, k int) bool {
        // m := len(nums)
        // if m < 2 {
        //     return false
        // }
        mp := map[int]int{0: -1}
        remainder := 0
        prevIndex:=-1
        has:=false
        for i, num := range nums {
            remainder = (remainder + num) % k
            prevIndex, has = mp[remainder]
            if has {
                if i-prevIndex >= 2 {
                    return true
                }
            } else {
                mp[remainder] = i
            }
        }
        return false
    }

# 6.3 

525. 连续数组


给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。

## 提示

哈希表的使用

## 代码

func findMaxLength(nums []int) (maxLength int) {
    mp := map[int]int{0: -1}
    counter := 0
    for i, num := range nums {
        if num == 1 {
            counter++
        } else {
            counter--
        }
        if prevIndex, has := mp[counter]; has {
            if maxLength<i-prevIndex{
                maxLength=i-prevIndex
            }
        } else {
            mp[counter] = i
        }
    }
    return
}

# 6.4

160. 相交链表


给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图示两个链表在节点 c1 开始相交：



题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

## 提示

简单操作就好

## 代码

    /**
     * Definition for singly-linked list.
     * type ListNode struct {
     *     Val int
     *     Next *ListNode
     * }
     */
    func getIntersectionNode(headA, headB *ListNode) *ListNode {
        data_a:=headA
        data_b:=headB
        if data_a==nil || data_b==nil{
            return nil
        }

        for ;data_a!=data_b;{
            if data_a==nil{
                data_a=headB
            }else{
                data_a=data_a.Next
            }
            if data_b==nil{
                data_b=headA
            }else{
                data_b=data_b.Next
            }
        }
        return data_a
    }

# 6.5

203. 移除链表元素


给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

## 提示

也可以创建虚拟节点来做这个题

## 代码

    /**
     * Definition for singly-linked list.
     * type ListNode struct {
     *     Val int
     *     Next *ListNode
     * }
     */
    func removeElements(head *ListNode, val int) *ListNode {
        for ;head!=nil&&head.Val==val;{
            head=head.Next
        }
        node:=head
        for ;node!=nil&&node.Next!=nil;{
            if node.Next.Val==val{
                node.Next=node.Next.Next
            }else{
            node=node.Next
            }
        }
        return head

    }

# 6.6

474. 一和零
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

## 提示

变种书包问题

## 代码
    func findMaxForm(strs []string, m, n int) int {
        dp := make([][]int, m+1)
        for i := range dp {
            dp[i] = make([]int, n+1)
        }
        for _, s := range strs {
            zeros := strings.Count(s, "0")
            ones := len(s) - zeros
            for j := m; j >= zeros; j-- {
                for k := n; k >= ones; k-- {
                    dp[j][k] = max(dp[j][k], dp[j-zeros][k-ones]+1)
                }
            }
        }
        return dp[m][n]
    }
    
    func max(a, b int) int {
        if a > b {
            return a
        }
        return b
    }

# 6.7

494. 目标和
给你一个整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：
例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

## 提示

DFS或DP

DP需要注意目标值的选取，(sum-neg)-neg=target

## 代码

func findTargetSumWays(nums []int, target int) int {
    sum := 0
    for _, v := range nums {
        sum += v
    }
    if sum - target < 0 || (sum - target)%2 == 1 {
        return 0
    }
    neg := (sum - target) / 2
    dp := make([]int, neg+1)
    dp[0] = 1
    for _, num := range nums {
        for j := neg; j >= num; j-- {
            dp[j] += dp[j-num]
        }
    }
    return dp[neg]
}

## 总结

很多dp都可以改造为深搜，或者说很多dp本身就是一种记忆化的深搜